# Java多线程

## 线程
1. 线程是进程内的执行单元，不分配单独的资源，执行一个单独的子任务。
2. 线程是进程内调度和分派的基本单位，共享进程资源。每个线程有自己的独立的栈存储空间，保存线程执行的方法以及基本类型的数据。
3. 运行的 Java 程序内含至少一个主线程 main ，用户可以在 Java 程序中自定义并调用多个线程。

### 线程的运行状态
- 创建
- 运行 (Running) CPU 正在执行线程。
- 就绪 (Runnable) 线程一切就绪，等待JVM调度。
- 阻塞 (Blocked) 线程因缺少其他资源，比如请求资源被上锁而暂停执行。在获得资源后进入就绪状态。
- 等待 (Waitting) 线程接受了等待指令，释放资源暂停执行。在超时/接受唤醒指令后进入就绪状态。
- 结束

### Runnable接口
Java中处理多线程使用的是Runnable接口
### Thread类
Thread类是Java自带的线程类，实现了Runnable接口。Thread主要有以下几种常用的创建方式
```java
public class ThreadDemo1 {
    public static void main(String[] args) {
        //通过使用Runnable对象创建创建线程
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {

            }
        });

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {

            }
        },"命名");
        // 通过lambada创建匿名内部类的方法创建线程，本质上与thread1相同，但是使用更方便
        Thread thread3 = new Thread(()->{});
    }
}
```
除此之外，还可以通过继承Thread的方式重写run方法，来给Thread添加具体的操作

```java
public class MyThread extends Thread {
   @Override
   public void run() {
       System.out.println(Thread.currentThread().getName());
   }
}
```
#### 启动线程
- Thread类定义了start方法。

- 调用start方法后，系统会开启一个新线程进入就绪状态：JVM会自动对线程进行调度，在运行时调用并执行线程的run方法。

- 一个线程只能启动一次。

#### 线程状态控制
- 创建->就绪start();
- 运行->就绪yield();
- 运行->暂停sleep(1000);
- 运行->等待wait()
- 等待->就绪notify()
- 运行->结束 强制结束：stop()；发送终止标志：interrupt()

## 线程池
线程池本质上是一种对象池，用于管理线程资源。在任务执行前，需要从线程池中拿出线程来执行。在任务执行完成之后，把线程放回线程池。

实际开发中，线程资源一般通过线程池提供，比如处理数据库连接、接收网络请求。 线程池可以使线程的创建更加规范，合理控制开辟线程的数量。
不必频繁地创建和销毁线程，优化了资源的开销。

### 线程池参数
- 核心线程池 (corePool) 
- 最大线程池 (maximumPool)
- 任务队列 (BlockQueue) 
- 拒绝策略 (RejectedExecutionHandler) 
#### 核心线程池
(corePool) 通常状况下，线程池最多能创建的线程数。

当有新任务等待处理时，线程池会首先判断核心线程池是否已满，如果没满则创建线程执行任务。即使有其他核心线程空闲也会创建新的核心线程来执行。

#### 最大线程池
(maximumPool) 任务量很大时，线程池最多能创建的线程数。

如果队列已满，说明当前任务量已经非常大，仅靠核心线程池内的线程数量已无法处理。线程池会判断最大线程池是否已满，如果没满则创建更多线程，从等待队列首部取得任务并执行。

#### 任务队列
(BlockQueue) 线程池中等待被线程执行的任务队列。

如果核心线程池已满，线程池会判断队列是否已满。如果队列没满，就会将任务放在队列中等待执行。

ArrayBlockingQueue // 基于数组实现的阻塞队列，有界。
LinkedBlockingQueue // 基于链表实现的阻塞队列，可以无界。
SynchronousQueue // 不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作。
PriorityBlockingQueue // 带优先级的阻塞队列，无界。

#### 拒绝策略
(RejectedExecutionHandler) 线程池拒绝过量任务的方式。

如果最大线程池已满，表示当前服务器已无法处理这么多任务。任务会按照既定的拒绝策略被处理。

CallerRunsPolicy // 在调用者线程执行。
AbortPolicy // 直接抛出 RejectedExecutionException 异常。
DiscardPolicy // （常用）任务直接丢弃，不做任何处理。
DiscardOldestPolicy // 丢弃队列里最旧的那个任务，再尝试执行当前任务。

## Future的使用
