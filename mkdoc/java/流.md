# 流

## 基础概念

流处理是对运动中的数据的处理，在生成或接收数据时直接计算数据。应用程序中分析和查询不断存在，数据不断地流经它们。

### Java Stream类

JDK 1.8 新增。将要处理的元素集合看作一种流，在管道的节点上进行处理。使代码更简洁易读。
集合接口有两个方法来生成流，数据类型将由 Collection 转化为 Stream 。

- stream 方法：为集合创建串行流。
- parallelStream 方法：为集合创建并行流。

1. Stream 的遍历方式和结果与 Iterator 无差别（便于转化），其优势在于其原型链的设计使得它可以对遍历处理后的数据进行再处理。
2. parallelStream 提供了流的并行处理，底层使用 Fork/Join 框架，简单理解就是多线程异步任务的一种实现。处理过程中会有多个线程处理元素，具体由
   JDK 负责管理。不保证有序性。
3. 串行流和并行流之间可以通过 parallel 和 sequential 方法相互转化。

```java
Stream<Integer> stream = list.stream(); // 声明作为流处理
ParellerStream<Integer> pStream = stream.parallel(); // 转化为并行流
```

### 流操作

流处理的每个操作阶段都会封装到一个 Sink 接口里，处理数据后再将数据传递给下游的 Sink。

Stream 上的所有操作分为两类：中间操作和结束操作。Stream 是延迟执行的，只有调用到结束操作，才触发整个流水线的执行。如果未定义结束操作，那么流处理什么也不会做。

```java
// 获取空字符串的数量
int count = strings.parallelStream()                       // 声明作为流处理
                   .filter(string -> string.isEmpty())     // 中间操作，过滤空元素
                   .count();                               // 结束操作，计数
```

## 中间操作

- map/flatMap
- filter
- limit/skip
- sorted
- distinct

### map/flatMap

- map的作用是把流里面的元素映射成另外一个元素，例如：

```java
List<Integer> squareNums = Arrays.asList(1, 2, 3, 4).stream().map(n -> n * n).collect(Collectors.toList());
```

- flatMap当需要将具有层级结构的数据展平时，也就是将多层数据转换为单层数据操作时，可以使用flatMap方法。

```java
Stream<List<Integer>> inputStream = Stream.of(Arrays.asList(1),Arrays.asList(2, 3),Arrays.asList(4, 5, 6));
List<Integer> result = inputStream.flatMap((childList) -> childList.stream()).collect(Collectors.toList());
System.out.println(result);
```

### filter

filter方法会过滤出符合条件的元素。比如以下例子会过滤出列表中的偶数。

```java
Stream<Integer> inputStream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
List<Integer> result = inputStream.filter(n -> n % 2 == 0).collect(Collectors.toList());
System.out.println(result);
```

输出结果

```bash
[2, 4, 6]
```

### limit/skip

limit方法用于获取前n个元素， skip方法用于除去前n个元素。

```java
// 取前3个元素
Stream<Integer> limitStream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
List<Integer> limitResult = limitStream.limit(3).collect(Collectors.toList());
System.out.println(limitResult);

// 去除去前3个元素
Stream<Integer> skipStream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
List<Integer> skipResult = skipStream.skip(3).collect(Collectors.toList());
System.out.println(skipResult);

// 去除去前2个元素，再取前3个元素
Stream<Integer> skipLimitStream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
List<Integer> skipLimitResult = skipLimitStream.skip(2).limit(3).collect(Collectors.toList());
System.out.println(skipLimitResult);

// 取前3个元素，再去除去前2个元素
Stream<Integer> limitSkipStream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
List<Integer> limitSkipResult = limitSkipStream.limit(3).skip(2).collect(Collectors.toList());
System.out.println(limitSkipResult);
```
运行结果
```java
[1, 2, 3]
[4, 5, 6]
[3, 4, 5]
[3]
```

### sorted
sorted方法通过Comparable接口对流进行排序，也可以自定义。

如果是Java的基本数据类型、基本数据类型包装类、字符、BigDecimal、日期等类型，则无需自定义规则（本质上是因为这些类都实现了Comparable接口）。

如果是自定义的类，可以通过实现Comparable接口的compareTo()方法来自定义排序逻辑，也可以通过传入Comparator对象的方式。
```java
Stream<Integer> inputStream = Arrays.asList(3, 1, 2, 5, 4, 6).stream();
List<Integer> result = inputStream.sorted().collect(Collectors.toList());
System.out.println(result);

// string类型会按照字符排序
Stream<Date> stringStream = Arrays.asList(new Date(0), new Date(121312312312L), new Date(1312312312L)).stream();
List<Date> stringResult = stringStream.sorted().collect(Collectors.toList());
System.out.println(stringResult);

// 实现Comparable接口
Stream<Person> personStream = Arrays.asList(new Person(1L, "张三", 18), new Person(2L, "李四", 20), new Person(3L, "王五", 16)).stream();
List<Person> personResult = personStream.sorted().collect(Collectors.toList());
System.out.println(personResult);

// 传入Comparator对象
Stream<Person> personStream1 = Arrays.asList(new Person(1L, "张三", 18), new Person(2L, "李四", 30), new Person(3L, "王五", 18)).stream();
List<Person> personResult1 = personStream1.sorted(
    Comparator.comparing(Person::getAge).reversed()
    .thenComparing(Person::getId)
    .thenComparing((v1,v2)->v1.getName().compareTo(v2.getName()))
).collect(Collectors.toList());
System.out.println(personResult1);
```
运行结果
```bash
[1, 2, 3, 4, 5, 6]
[Thu Jan 01 00:00:00 UTC 1970, Fri Jan 16 04:31:52 UTC 1970, Mon Nov 05 01:51:52 UTC 1973]
[Person [id=3, name=王五, age=16], Person [id=1, name=张三, age=18], Person [id=2, name=李四, age=20]]
[Person [id=2, name=李四, age=30], Person [id=1, name=张三, age=18], Person [id=3, name=王五, age=18]]
```

## 结束操作